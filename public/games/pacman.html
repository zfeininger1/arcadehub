<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man - Arcade Hub</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Poppins:wght@300;400;600;700;900&display=swap"
        rel="stylesheet">

    <!-- Mobile Controls CSS -->
    <link rel="stylesheet" href="../css/mobile-controls.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(15, 12, 41, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
        }

        nav a {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        nav a:hover {
            color: #00ffff;
            transform: translateX(-5px);
        }

        /* Game Container */
        .game-container {
            margin-top: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 15px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Main game area - horizontal layout */
        .game-area {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Left side - canvas and info */
        .game-left {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        /* Right side - instructions and controls */
        .game-right {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 350px;
            margin-top: 120px;
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1.5rem, 4vw, 3rem);
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
            margin-bottom: 10px;
        }

        .game-info {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            color: #00ffff;
            text-align: center;
            line-height: 1.8;
        }

        .score-display {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: #ff00ff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            margin-top: 10px;
        }

        /* Canvas Container */
        .canvas-container {
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(20px);
            border: 3px solid #ff00ff;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
            position: relative;
        }

        canvas {
            display: block;
            background: #000;
            border: 2px solid #00ffff;
            border-radius: 10px;
            box-shadow: inset 0 0 20px rgba(0, 255, 255, 0.3);
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            padding: 15px 30px;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(255, 0, 255, 0.4);
            text-transform: uppercase;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 40px rgba(255, 0, 255, 0.7);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: left;
        }

        .instructions h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: #00ffff;
            margin-bottom: 15px;
        }

        .instructions p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
        }

        .key-hint {
            display: inline-block;
            background: rgba(255, 0, 255, 0.2);
            border: 1px solid #ff00ff;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: 600;
            color: #ff00ff;
            margin: 0 3px;
        }

        /* Responsive */
        @media (max-width: 968px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }

            .game-right {
                max-width: 500px;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            .game-info {
                font-size: 0.7rem;
            }

            canvas {
                width: 100%;
                height: auto;
            }

            button {
                font-size: 0.7rem;
                padding: 12px 20px;
            }

            /* Ensure game container has enough bottom space for mobile controls */
            .game-container {
                padding-bottom: 20px;
                margin-bottom: 0;
            }

            /* Center the game area on mobile */
            .game-area {
                width: 100%;
            }

            /* Hide keyboard hints on mobile */
            .key-hint {
                display: none;
            }

            /* Show mobile instructions */
            .mobile-instructions {
                display: block !important;
            }
        }

        .title-icon {
            -webkit-text-fill-color: #39ff14;
            text-shadow: 0 0 20px rgba(57, 255, 20, 0.8);
        }
    </style>
</head>

<body>
    <!-- Navigation -->
    <nav>
        <a href="../hub.html">
            <span style="font-size: 1.5rem;">üéÆ</span>
            <span>Arcade Hub</span>
        </a>
        <a href="../login.html" style="
            display: inline-block;
            padding: 8px 20px;
            background: transparent;
            border: 2px solid #fff;
            border-radius: 50px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            text-decoration: none;
            transition: all 0.3s ease;
            margin-left: auto;
        " onmouseover="this.style.background='#fff'; this.style.color='#333';"
            onmouseout="this.style.background='transparent'; this.style.color='#fff';">
            LOGIN
        </a>
    </nav>

    <!-- Game Container -->
    <div class="game-container">
        <h1><span class="title-icon">üëª</span> PAC-MAN <span class="title-icon">üëª</span></h1>

        <!-- Main game area with horizontal layout -->
        <div class="game-area">
            <!-- Left side: Canvas and scores -->
            <div class="game-left">
                <div class="game-info">
                    <p id="gameStatus">GET READY!</p>
                    <div class="score-display">Score: <span id="scoreDisplay">0</span></div>
                    <div class="score-display" style="font-size: 0.8rem; margin-top: 5px;">High Score: <span
                            id="highScore">0</span></div>
                </div>

                <div class="canvas-container">
                    <canvas id="gameCanvas" width="520" height="280"></canvas>
                </div>
            </div>

            <!-- Right side: Instructions and controls -->
            <div class="game-right">
                <div class="instructions">
                    <h2>How to Play</h2>
                    <p class="desktop-instructions">Use <span class="key-hint">W</span> <span class="key-hint">A</span>
                        <span class="key-hint">S</span> <span class="key-hint">D</span> keys to move</p>
                    <p class="mobile-instructions" style="display: none;">Tap the screen in the direction you want to
                        move</p>
                    <p>Eat all the dots to win!</p>
                    <p>Avoid the ghosts or they'll catch you!</p>
                    <p>Eat power pellets to chase ghosts for bonus points!</p>
                </div>

                <div class="controls">
                    <button id="startBtn">Start Game</button>
                    <button id="pauseBtn" disabled>Pause</button>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div class="direction-pad" id="pacmanDPad">
                <button class="control-btn" data-key="KeyW">‚Üë<br><small>W</small></button>
                <button class="control-btn" data-key="KeyA">‚Üê<br><small>A</small></button>
                <button class="control-btn" data-key="KeyD">‚Üí<br><small>D</small></button>
                <button class="control-btn" data-key="KeyS">‚Üì<br><small>S</small></button>
            </div>
        </div>
    </div>

    <script>
        // Check if running in campaign mode
        const urlParams = new URLSearchParams(window.location.search);
        const isCampaignMode = urlParams.get('campaign') === 'true';

        // Hide login button in campaign mode
        if (isCampaignMode) {
            const loginBtn = document.querySelector('nav a[href="../login.html"]');
            if (loginBtn) loginBtn.style.display = 'none';
        }

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScore');
        const gameStatus = document.getElementById('gameStatus');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');

        // API Configuration
        // REPLACE THIS WITH YOUR ACTUAL API GATEWAY URL AFTER DEPLOYMENT
        const API_URL = 'https://0oxjdgrxii.execute-api.us-east-2.amazonaws.com/DEV/pacman-scores';

        // Game constants
        const TILE_SIZE = 20;
        const COLS = 26;
        const ROWS = 14;

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let highScore = 0;
        let animationId;
        let powerMode = false;
        let powerModeTimer = 0;
        let frameCounter = 0;
        const MOVE_DELAY = 12; // Pac-Man moves every 12 frames (~5 times per second)
        const GHOST_DELAY = 16; // Ghosts move every 16 frames (~4 times per second)

        // Campaign-specific state
        let campaignLivesLost = 0;
        const CAMPAIGN_MAX_LIVES = 3;

        // Maze layout (1=wall, 0=dot, 2=power pellet, 3=empty) - Fixed symmetrical design
        let maze = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 2, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 2, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1],
            [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // Pac-Man - spawn in bottom area
        let pacman = {
            x: 13,
            y: 12,
            direction: 0,
            nextDirection: 0,
            mouthOpen: true,
            animationCounter: 0
        };

        // Ghosts - spawn in center open corridor (row 8) - each at different position
        let ghosts = [
            { x: 11, y: 8, color: '#ff0000', direction: 0, name: 'Blinky' },
            { x: 12, y: 8, color: '#ffb8ff', direction: 2, name: 'Pinky' },
            { x: 13, y: 8, color: '#00ffff', direction: 1, name: 'Inky' },
            { x: 14, y: 8, color: '#ffb852', direction: 3, name: 'Clyde' }
        ];

        let originalMaze = JSON.parse(JSON.stringify(maze));
        let dotsRemaining = 0;

        // Direction vectors
        const dx = [1, 0, -1, 0];
        const dy = [0, 1, 0, -1];

        // Generate a random maze
        function generateMaze() {
            // Start with all walls
            const newMaze = Array(ROWS).fill(0).map(() => Array(COLS).fill(1));

            // Make border walls
            for (let y = 0; y < ROWS; y++) {
                newMaze[y][0] = 1;
                newMaze[y][COLS - 1] = 1;
            }
            for (let x = 0; x < COLS; x++) {
                newMaze[0][x] = 1;
                newMaze[ROWS - 1][x] = 1;
            }

            // Fill interior with dots
            for (let y = 1; y < ROWS - 1; y++) {
                for (let x = 1; x < COLS - 1; x++) {
                    newMaze[y][x] = 0; // dot
                }
            }

            // Add random wall blocks (but not too many)
            const numWallBlocks = Math.floor((ROWS * COLS) * 0.15); // 15% walls
            for (let i = 0; i < numWallBlocks; i++) {
                const x = Math.floor(Math.random() * (COLS - 4)) + 2;
                const y = Math.floor(Math.random() * (ROWS - 4)) + 2;

                // Create small wall blocks (2x2 or 2x3)
                const width = Math.random() > 0.5 ? 2 : 3;
                const height = Math.random() > 0.5 ? 2 : 3;

                for (let dy = 0; dy < height && y + dy < ROWS - 1; dy++) {
                    for (let dx = 0; dx < width && x + dx < COLS - 1; dx++) {
                        newMaze[y + dy][x + dx] = 1;
                    }
                }
            }

            // Create ghost spawn area in center
            const centerX = Math.floor(COLS / 2);
            const centerY = Math.floor(ROWS / 2);
            newMaze[centerY][centerX] = 3;
            newMaze[centerY][centerX - 1] = 3;
            if (centerY > 0) newMaze[centerY - 1][centerX] = 3;
            if (centerY > 0) newMaze[centerY - 1][centerX - 1] = 3;

            // Add power pellets in corners
            newMaze[2][2] = 2;
            newMaze[2][COLS - 3] = 2;
            newMaze[ROWS - 3][2] = 2;
            newMaze[ROWS - 3][COLS - 3] = 2;

            // Ensure there are some corridors for gameplay
            // Create horizontal corridors
            for (let y = 3; y < ROWS - 3; y += 4) {
                for (let x = 2; x < COLS - 2; x++) {
                    if (newMaze[y][x] === 1 && Math.random() > 0.3) {
                        newMaze[y][x] = 0;
                    }
                }
            }

            // Create vertical corridors
            for (let x = 3; x < COLS - 3; x += 4) {
                for (let y = 2; y < ROWS - 2; y++) {
                    if (newMaze[y][x] === 1 && Math.random() > 0.3) {
                        newMaze[y][x] = 0;
                    }
                }
            }

            return newMaze;
        }

        // Input handling - WASD controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;

            const key = e.key.toLowerCase();
            if (key === 'd') pacman.nextDirection = 0;
            else if (key === 's') pacman.nextDirection = 1;
            else if (key === 'a') pacman.nextDirection = 2;
            else if (key === 'w') pacman.nextDirection = 3;
        });

        function countDots() {
            let count = 0;
            for (let row of maze) {
                for (let cell of row) {
                    if (cell === 0 || cell === 2) count++;
                }
            }
            return count;
        }

        function canMove(x, y, dir) {
            const newX = x + dx[dir];
            const newY = y + dy[dir];
            return maze[newY] && maze[newY][newX] !== 1;
        }

        function movePacman() {
            // Try to change direction
            if (canMove(pacman.x, pacman.y, pacman.nextDirection)) {
                pacman.direction = pacman.nextDirection;
            }

            // Move in current direction
            if (canMove(pacman.x, pacman.y, pacman.direction)) {
                pacman.x += dx[pacman.direction];
                pacman.y += dy[pacman.direction];

                // Check for dots
                const cell = maze[pacman.y][pacman.x];
                if (cell === 0) {
                    maze[pacman.y][pacman.x] = 3;
                    score += 10;
                    dotsRemaining--;
                } else if (cell === 2) {
                    maze[pacman.y][pacman.x] = 3;
                    score += 50;
                    dotsRemaining--;
                    powerMode = true;
                    powerModeTimer = 300; // 300 frames = 5 seconds at 60 FPS
                }
            }

            // Animation
            pacman.animationCounter++;
            if (pacman.animationCounter % 10 === 0) {
                pacman.mouthOpen = !pacman.mouthOpen;
            }
        }

        function moveGhost(ghost, index) {
            // Find all possible directions
            const possibleDirs = [];

            for (let i = 0; i < 4; i++) {
                const testX = ghost.x + dx[i];
                const testY = ghost.y + dy[i];
                // Check if move is valid
                if (testX >= 0 && testX < COLS && testY >= 0 && testY < ROWS &&
                    maze[testY] && maze[testY][testX] !== 1) {
                    possibleDirs.push(i);
                }
            }

            // If we have valid moves, pick one
            if (possibleDirs.length > 0) {
                let chosenDir;

                if (!powerMode && Math.random() < 0.7 && possibleDirs.length > 1) {
                    // Chase Pac-Man
                    const distX = pacman.x - ghost.x;
                    const distY = pacman.y - ghost.y;

                    let preferredDir;
                    if (Math.abs(distX) > Math.abs(distY)) {
                        preferredDir = distX > 0 ? 0 : 2;
                    } else {
                        preferredDir = distY > 0 ? 1 : 3;
                    }

                    if (possibleDirs.includes(preferredDir)) {
                        chosenDir = preferredDir;
                    } else {
                        // Pick random from available
                        chosenDir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                    }
                } else if (powerMode && possibleDirs.length > 1) {
                    // Flee from Pac-Man
                    const distX = pacman.x - ghost.x;
                    const distY = pacman.y - ghost.y;
                    let fleeDir;
                    if (Math.abs(distX) > Math.abs(distY)) {
                        fleeDir = distX > 0 ? 2 : 0;
                    } else {
                        fleeDir = distY > 0 ? 3 : 1;
                    }
                    if (possibleDirs.includes(fleeDir)) {
                        chosenDir = fleeDir;
                    } else {
                        chosenDir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                    }
                } else {
                    // Random or only one option
                    chosenDir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                }

                // Move in chosen direction
                ghost.x += dx[chosenDir];
                ghost.y += dy[chosenDir];
                ghost.direction = chosenDir;
            }
        }

        function checkCollisions() {
            for (let ghost of ghosts) {
                if (ghost.x === pacman.x && ghost.y === pacman.y) {
                    if (powerMode) {
                        score += 200;
                        ghost.x = 11 + Math.floor(Math.random() * 4);
                        ghost.y = 8;
                    } else {
                        // Game over - stop game immediately to prevent extra score updates
                        gameRunning = false;
                        gameOver(false);
                        return false;
                    }
                }
            }
            return true;
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = maze[y][x];

                    if (cell === 1) {
                        // Wall - purple/magenta to distinguish from blue ghosts
                        ctx.fillStyle = '#8800ff';
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        ctx.strokeStyle = '#aa44ff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else if (cell === 0) {
                        // Dot
                        ctx.fillStyle = '#ffb8ae';
                        ctx.beginPath();
                        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 2) {
                        // Power pellet
                        ctx.fillStyle = '#ffb8ae';
                        ctx.beginPath();
                        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw Pac-Man
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            const centerX = pacman.x * TILE_SIZE + TILE_SIZE / 2;
            const centerY = pacman.y * TILE_SIZE + TILE_SIZE / 2;
            const radius = TILE_SIZE / 2 - 2;

            if (pacman.mouthOpen) {
                const angle = pacman.direction * Math.PI / 2;
                ctx.arc(centerX, centerY, radius, angle + 0.2, angle - 0.2 + Math.PI * 2);
                ctx.lineTo(centerX, centerY);
            } else {
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            }
            ctx.fill();

            // Draw ghosts
            for (let ghost of ghosts) {
                ctx.fillStyle = powerMode ? '#0000ff' : ghost.color;
                const gx = ghost.x * TILE_SIZE + TILE_SIZE / 2;
                const gy = ghost.y * TILE_SIZE + TILE_SIZE / 2;

                // Ghost body
                ctx.beginPath();
                ctx.arc(gx, gy - 3, radius, Math.PI, 0);
                ctx.lineTo(gx + radius, gy + radius);
                ctx.lineTo(gx + radius / 2, gy + radius - 3);
                ctx.lineTo(gx, gy + radius);
                ctx.lineTo(gx - radius / 2, gy + radius - 3);
                ctx.lineTo(gx - radius, gy + radius);
                ctx.closePath();
                ctx.fill();

                // Ghost eyes
                if (!powerMode) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(gx - 5, gy - 5, 4, 6);
                    ctx.fillRect(gx + 1, gy - 5, 4, 6);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(gx - 3, gy - 3, 2, 3);
                    ctx.fillRect(gx + 3, gy - 3, 2, 3);
                }
            }
        }

        function update() {
            if (!gameRunning || gamePaused) return;

            frameCounter++;

            // Move Pac-Man at regular intervals
            if (frameCounter % MOVE_DELAY === 0) {
                movePacman();
            }

            // Move ghosts slower than Pac-Man
            if (frameCounter % GHOST_DELAY === 0) {
                for (let i = 0; i < ghosts.length; i++) {
                    moveGhost(ghosts[i], i);
                }
            }

            if (!checkCollisions()) return;

            // Update power mode
            if (powerMode) {
                powerModeTimer--;
                if (powerModeTimer <= 0) {
                    powerMode = false;
                }
            }

            // Check win condition
            if (dotsRemaining === 0) {
                gameOver(true);
                return;
            }

            updateScore(score);
            draw();
            animationId = requestAnimationFrame(update);
        }

        function updateScore(newScore) {
            score = newScore;
            scoreDisplay.textContent = score;
            if (score > highScore) {
                highScore = score;
                highScoreDisplay.textContent = highScore;
            }
        }

        function gameOver(won) {
            if (won) {
                // Player won level!
                if (isCampaignMode) {
                    // Campaign mode: Stop game and send win message
                    gameRunning = false;
                    gamePaused = false;
                    cancelAnimationFrame(animationId);
                    gameStatus.textContent = "LEVEL COMPLETE!";

                    // Save score then send message
                    saveScore(score).then(() => {
                        // Send win message to parent
                        if (window.parent !== window) {
                            console.log('Sending campaign win message. Score:', score);
                            window.parent.postMessage({
                                type: 'gameOver',
                                levelCompleted: true,
                                score: score
                            }, '*');
                        }
                    });
                } else {
                    // Guest mode: Auto-restart with preserved score
                    gameStatus.textContent = "LEVEL COMPLETE!";
                    cancelAnimationFrame(animationId);

                    // Brief pause before restarting
                    setTimeout(() => {
                        // Reset maze and positions but keep score
                        maze = JSON.parse(JSON.stringify(originalMaze));
                        dotsRemaining = countDots();
                        frameCounter = 0;
                        pacman = {
                            x: 13,
                            y: 12,
                            direction: 0,
                            nextDirection: 0,
                            mouthOpen: true,
                            animationCounter: 0
                        };
                        ghosts = [
                            { x: 11, y: 8, color: '#ff0000', direction: 0, name: 'Blinky' },
                            { x: 12, y: 8, color: '#ffb8ff', direction: 2, name: 'Pinky' },
                            { x: 13, y: 8, color: '#00ffff', direction: 1, name: 'Inky' },
                            { x: 14, y: 8, color: '#ffb852', direction: 3, name: 'Clyde' }
                        ];
                        powerMode = false;
                        powerModeTimer = 0;

                        gameStatus.textContent = "PLAYING";
                        gameRunning = true;
                        gamePaused = false;

                        draw();
                        update();
                    }, 1500); // 1.5 second pause to show victory message
                }
            } else {
                // Player lost - caught by ghost
                if (isCampaignMode) {
                    campaignLivesLost++;
                    console.log('Campaign lives lost:', campaignLivesLost);

                    if (campaignLivesLost >= CAMPAIGN_MAX_LIVES) {
                        // Campaign loss - out of lives
                        gameRunning = false;
                        gamePaused = false;
                        cancelAnimationFrame(animationId);
                        gameStatus.textContent = "GAME OVER";

                        // Save score then send message
                        saveScore(score).then(() => {
                            // Send loss message to parent
                            if (window.parent !== window) {
                                console.log('Sending campaign loss message. Score:', score, 'Lives lost:', campaignLivesLost);
                                window.parent.postMessage({
                                    type: 'gameOver',
                                    levelCompleted: false,
                                    score: score
                                }, '*');
                            }
                        });
                    } else {
                        // Still have lives - brief pause then continue
                        gameRunning = false;
                        cancelAnimationFrame(animationId);
                        gameStatus.textContent = `LIFE LOST! ${CAMPAIGN_MAX_LIVES - campaignLivesLost} LEFT`;

                        setTimeout(() => {
                            // Reset positions but keep score and dots
                            pacman = {
                                x: 13,
                                y: 12,
                                direction: 0,
                                nextDirection: 0,
                                mouthOpen: true,
                                animationCounter: 0
                            };
                            ghosts = [
                                { x: 11, y: 8, color: '#ff0000', direction: 0, name: 'Blinky' },
                                { x: 12, y: 8, color: '#ffb8ff', direction: 2, name: 'Pinky' },
                                { x: 13, y: 8, color: '#00ffff', direction: 1, name: 'Inky' },
                                { x: 14, y: 8, color: '#ffb852', direction: 3, name: 'Clyde' }
                            ];
                            powerMode = false;
                            powerModeTimer = 0;

                            gameStatus.textContent = "PLAYING";
                            gameRunning = true;
                            gamePaused = false;
                            draw();
                            update();
                        }, 1500);
                    }
                } else {
                    // Guest mode - stop the game
                    gameRunning = false;
                    gamePaused = false;
                    cancelAnimationFrame(animationId);

                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                    startBtn.textContent = "Play Again";
                    gameStatus.textContent = "GAME OVER";

                    // Save score and update high score
                    saveScore(score).then(() => {
                        fetchHighScore();
                    });
                }
            }
        }

        // Save score to DynamoDB via Lambda
        async function saveScore(finalScore) {
            try {
                console.log('Attempting to save score:', finalScore);

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'save_score',
                        player_id: 'anonymous',
                        score: finalScore
                    })
                });

                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }

                const result = await response.json();
                console.log('‚úÖ Score saved successfully:', result);
            } catch (error) {
                console.error('‚ùå Error saving score:', error);
            }
        }

        // Fetch high score from DynamoDB
        async function fetchHighScore() {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'get_high_score'
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    // Handle double-wrapped JSON if necessary (common with Lambda proxy integration)
                    const data = typeof result.body === 'string' ? JSON.parse(result.body) : result;
                    highScore = data.high_score || 0;
                    highScoreDisplay.textContent = highScore;
                    console.log('‚úÖ High score loaded:', highScore);
                }
            } catch (error) {
                console.error('‚ùå Error fetching high score:', error);
                highScoreDisplay.textContent = '-';
            }
        }

        // Load high score on startup
        fetchHighScore();

        function startGame() {
            if (gameRunning && !gamePaused) return;

            if (gamePaused) {
                gamePaused = false;
                gameRunning = true;
                pauseBtn.textContent = "Pause";
                gameStatus.textContent = "PLAYING";
                update();
                return;
            }

            // Reset game
            maze = JSON.parse(JSON.stringify(originalMaze));
            dotsRemaining = countDots();
            frameCounter = 0;
            pacman = {
                x: 13,
                y: 12,
                direction: 0,
                nextDirection: 0,
                mouthOpen: true,
                animationCounter: 0
            };
            ghosts = [
                { x: 11, y: 8, color: '#ff0000', direction: 0, name: 'Blinky' },
                { x: 12, y: 8, color: '#ffb8ff', direction: 2, name: 'Pinky' },
                { x: 13, y: 8, color: '#00ffff', direction: 1, name: 'Inky' },
                { x: 14, y: 8, color: '#ffb852', direction: 3, name: 'Clyde' }
            ];
            powerMode = false;
            powerModeTimer = 0;

            gameRunning = true;
            gamePaused = false;
            score = 0;
            updateScore(0);
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            startBtn.textContent = "Playing...";
            gameStatus.textContent = "PLAYING";

            draw();
            update();
        }

        function togglePause() {
            if (!gameRunning && !gamePaused) return;

            gamePaused = !gamePaused;

            if (gamePaused) {
                pauseBtn.textContent = "Resume";
                gameStatus.textContent = "PAUSED";
                cancelAnimationFrame(animationId);
            } else {
                pauseBtn.textContent = "Pause";
                gameStatus.textContent = "PLAYING";
                update();
            }
        }

        function resetGame() {
            gameRunning = false;
            gamePaused = false;
            cancelAnimationFrame(animationId);
            score = 0;
            updateScore(0);

            maze = JSON.parse(JSON.stringify(originalMaze));
            pacman = { x: 13, y: 12, direction: 0, nextDirection: 0, mouthOpen: true, animationCounter: 0 };
            ghosts = [
                { x: 11, y: 8, color: '#ff0000', direction: 0, name: 'Blinky' },
                { x: 12, y: 8, color: '#ffb8ff', direction: 2, name: 'Pinky' },
                { x: 13, y: 8, color: '#00ffff', direction: 1, name: 'Inky' },
                { x: 14, y: 8, color: '#ffb852', direction: 3, name: 'Clyde' }
            ];
            powerMode = false;

            startBtn.disabled = false;
            pauseBtn.disabled = true;
            pauseBtn.textContent = "Pause";
            startBtn.textContent = "Start Game";
            gameStatus.textContent = "GET READY!";

            draw();
        }

        // Event listeners
        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', togglePause);
        resetBtn.addEventListener('click', resetGame);

        // Mobile touch controls - canvas based
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            // Scale touch coordinates to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = touchX * scaleX;
            const canvasY = touchY * scaleY;

            // Get Pac-Man position in pixels
            const pacX = pacman.x * TILE_SIZE + TILE_SIZE / 2;
            const pacY = pacman.y * TILE_SIZE + TILE_SIZE / 2;

            // Calculate difference
            const dx = canvasX - pacX;
            const dy = canvasY - pacY;

            // Determine direction based on which axis has more movement
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal movement
                if (dx > 0) {
                    pacman.nextDirection = 0; // Right (D)
                } else {
                    pacman.nextDirection = 2; // Left (A)
                }
            } else {
                // Vertical movement
                if (dy > 0) {
                    pacman.nextDirection = 1; // Down (S)
                } else {
                    pacman.nextDirection = 3; // Up (W)
                }
            }
        });

        // Initialize
        dotsRemaining = countDots();
        originalMaze = JSON.parse(JSON.stringify(maze));
        draw();
    </script>
</body>

</html>
```